<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
    
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        
        .button-grid {
        display: flex;             /* à¤¸à¤°à¥à¤µ à¤¬à¤Ÿà¤£ à¤•à¤‚à¤Ÿà¥‡à¤¨à¤°à¥à¤¸ à¤à¤•à¤¾ à¤“à¤³à¥€à¤¤ à¤ à¥‡à¤µà¤¤à¥‹ */
        flex-wrap: wrap;           /* à¤œà¤° à¤¬à¤Ÿà¤£à¥‡ à¤œà¤¾à¤¸à¥à¤¤ à¤à¤¾à¤²à¥€ à¤¤à¤° à¤¤à¥€ à¤ªà¥à¤¢à¤šà¥à¤¯à¤¾ à¤“à¤³à¥€à¤¤ à¤œà¤¾à¤¤à¥€à¤² */
        gap: 10px;                 /* à¤ªà¥à¤°à¤¤à¥à¤¯à¥‡à¤• à¤¬à¤Ÿà¤£ à¤•à¤‚à¤Ÿà¥‡à¤¨à¤°à¤®à¤§à¥à¤¯à¥‡ à¤…à¤‚à¤¤à¤° à¤ à¥‡à¤µà¤¤à¥‹ */
        padding: 15px;
        border: 2px solid #ccc;    /* à¤®à¥à¤–à¥à¤¯ à¤¬à¥‰à¤•à¥à¤¸à¤²à¤¾ à¤¬à¥‰à¤°à¥à¤¡à¤° à¤¦à¤¿à¤²à¥€ à¤†à¤¹à¥‡ */
        border-radius: 8px;
        background-color: #e9ecef; /* à¤¬à¥‰à¤•à¥à¤¸à¤¸à¤¾à¤ à¥€ à¤¹à¤²à¤•à¤¾ à¤¬à¥…à¤•à¤—à¥à¤°à¤¾à¤‰à¤‚à¤¡ */
    }
        /*.container {
            max-width: 200px;
            margin: auto;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }*/

        .program-section {
            border: 1px solid #ddd;
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 6px;
            background-color: #f9f9f9;
        }

        .program-title {
            margin-top: 0;
            color: #0056b3;
        }

        button {
            padding: 5px 10px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #0056b3;
        }

        /* ******************************************* */
        /* CSS code: à¤¹à¤¾ à¤•à¥‹à¤¡ à¤ªà¥à¤°à¥‹à¤—à¥à¤°à¤¾à¤®à¤šà¤¾ à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ à¤¸à¥à¤•à¥à¤°à¥€à¤¨à¤µà¤° à¤¦à¤¿à¤¸à¥‚ à¤¦à¥‡à¤£à¤¾à¤° à¤¨à¤¾à¤¹à¥€ */
        /* ******************************************* */
        .program-code {
            /* à¤•à¥‹à¤¡ à¤à¤°à¤¿à¤¯à¤¾ à¤²à¤ªà¤µà¤£à¥à¤¯à¤¾à¤¸à¤¾à¤ à¥€ 'opacity: 0' à¤†à¤£à¤¿ 'pointer-events: none' à¤šà¤¾ à¤µà¤¾à¤ªà¤° à¤•à¥‡à¤²à¤¾ à¤†à¤¹à¥‡ */
            opacity: 0;
            position: absolute;
            left: -9999px; /* à¤¸à¥à¤•à¥à¤°à¥€à¤¨à¤šà¥à¤¯à¤¾ à¤¬à¤¾à¤¹à¥‡à¤° à¤¢à¤•à¤²à¤£à¥à¤¯à¤¾à¤¸à¤¾à¤ à¥€ */
            width: 1px;
            height: 1px;
            pointer-events: none; /* à¤®à¤¾à¤Šà¤¸ à¤‡à¤µà¥à¤¹à¥‡à¤‚à¤Ÿà¥à¤¸ à¤¥à¤¾à¤‚à¤¬à¤µà¤£à¥à¤¯à¤¾à¤¸à¤¾à¤ à¥€ */
        }
        
        /* à¤•à¥‰à¤ªà¥€ à¤¸à¥à¤Ÿà¥‡à¤Ÿà¤¸à¤¸à¤¾à¤ à¥€ à¤¸à¥à¤Ÿà¤¾à¤‡à¤²à¤¿à¤‚à¤— */
        .copied {
            background-color: #28a745;
        }
    </style>
</head>
<body>

    <div class="button-grid">
    <h1></h1>
    <p></p>

    <div class="program-section">
        <h2 class="program-title"></h2>
        
        <textarea id="program1" class="program-code">
        Q1  
            import numpy as np
def objective_function(x):
Â  Â  return -x**2 + 4*x
def hill_climbing(initial_x, step_size, iterations):
Â  Â  current_x = initial_x
Â  Â  for _ in range(iterations):
Â  Â  Â  Â  current_value = objective_function(current_x)
Â  Â  Â  Â  next_x = current_x + step_size
Â  Â  Â  Â  next_value = objective_function(next_x)
Â  Â  if next_value > current_value:
Â  Â  Â  Â  current_x = next_x
Â  Â  return current_x, objective_function(current_x)
# Example usage
initial_x = 0.0
step_size = 0.1
iterations = 50
max_x, max_value = hill_climbing(initial_x, step_size, iterations)
print(f"Maximum value found at x = {max_x}, f(x) = {max_value}")
           
            

        Q2 #dfs
            graph={
            '1':['2','3'],
            '2':['4','5'],
            '3':['6','7'],
            '4':['8'],
            '5':['8'],
            '6':['8'],
            '7':['8'],
            '8':[],
      }
         visited=set()
            found=False
            def dfs(visited,graph,initial_node,goal_node):
              global found
              if found:
                  return
            if initial_node not in visited:
                      print(initial_node)
                      visited.add(initial_node)
                      if initial_node==goal_node:
                             print("goal node found")
                             found=True
                             return
                      for neighbour in graph[initial_node]:
                            dfs(visited,graph,neighbour,goal_node)
            dfs(visited,graph,'1','8')
            
        </textarea>
        
        <button id="btn-program1" onclick="copyProgram('program1', 'btn-program1')">slip1</button>
    </div>

    <div class="program-section">
        <h2 class="program-title"></h2>
        
        <textarea id="program2" class="program-code">
     Q1 
     import calendar
     y = int(input("Input the year : "))
     m = int(input("Input the month : "))
     print("your calendar:")
     print(calendar.month(y, m))
     
     Q2 
            #dfs
            graph={
            '1':['2','3'],
            '2':['4','5'],
            '3':['6','7'],
            '4':['8'],
            '5':['8'],
            '6':['8'],
            '7':['8'],
            '8':[],
      }
         visited=set()
            found=False
            def dfs(visited,graph,initial_node,goal_node):
              global found
              if found:
                  return
            if initial_node not in visited:
                      print(initial_node)
                      visited.add(initial_node)
                      if initial_node==goal_node:
                             print("goal node found")
                             found=True
                             return
                      for neighbour in graph[initial_node]:
                            dfs(visited,graph,neighbour,goal_node)
            dfs(visited,graph,'1','8')
            
            
        </textarea>
        
        <button id="btn-program2" onclick="copyProgram('program2', 'btn-program2')">slip2</button>
    </div>
    
    <div class="program-section">
        <h2 class="program-title"></h2>
        
        <textarea id="program3" class="program-code">
     Q.1
            import string
            text=input("enter string")
            puncfree="".join(char for char in text if char not in string.punctuation)
            print("string without punctuation")
            print(puncfree)
     
     Q2 
        #dfs
            graph={
            '1':['2','3'],
            '2':['4','5'],
            '3':['6','7'],
            '4':['8'],
            '5':['8'],
            '6':['8'],
            '7':['8'],
            '8':[],
      }
         visited=set()
            found=False
            def dfs(visited,graph,initial_node,goal_node):
              global found
              if found:
                  return
            if initial_node not in visited:
                      print(initial_node)
                      visited.add(initial_node)
                      if initial_node==goal_node:
                             print("goal node found")
                             found=True
                             return
                      for neighbour in graph[initial_node]:
                            dfs(visited,graph,neighbour,goal_node)
            dfs(visited,graph,'1','8')
            
       
        </textarea>
        
        <button id="btn-program3" onclick="copyProgram('program3', 'btn-program3')">slip3</button>
    </div>

    <div class="program-section">
        <h2 class="program-title"></h2>
        
        <textarea id="program4" class="program-code">
    Q1 
            #hangman
            import random
            words=['ghost','devil','python','iblis','lilith','programming','science']
            word=random.choice(words)
            guessed_letters=[]
            attempts=10

            print("welcoome to hangman !")
            print("__"* len(word))

            while attempts>0:
                 guess=input("\guess a letter").lower()

            if len(guess)!=1 or not guess.isalpha():
               print("please enter a single alpahabet letter")
               continue

            if guess in guessed_letters:
               print("you already guessed that letter ")
               continue
            guessed_letters.append(guess)

            if guess in word:
                print("nice guess")
            else:
                attempts-=1
                print("wrong guess now you have only attempts ",attempts)

            display_word=""
            for letter in word:
                 if letter in guessed_letters:
                     display_word +=letter + ""
                 else:
                      display_word += "__"
            print(display_word.strip())

            if "__" not in display_word:
                print("\n u guessed correct word",word)
                break
    else:
            print("\n sorry no more attempts the word was ",word)

     Q2. #bfs
            from collections import deque
            def bfs(graph,root,goal):
               visited=set()
               queue=deque([root])
               visited.add(root)

            while queue:
                vertex=queue.popleft()
                print(vertex,end=" ")
                if vertex==goal:
                   print("goal found")
                   return

                for neighbour in graph.get(vertex,[]):
                     if neighbour not in visited:
                         visited.add(neighbour)
                          queue.append(neighbour)

            graph={
            '1':['2','3'],
            '2':['4','5'],
            '3':['6','7'],
            '4':['8'],
            '5':['8'],
            '6':['8'],
            '7':['8'],
            '8':[],
    }
            bfs(graph,'2','8')
        </textarea>
        
        <button id="btn-program4" onclick="copyProgram('program4', 'btn-program4')">slip4</button>
    </div>
      
    <div class="program-section">
        <h2 class="program-title"></h2>
        
        <textarea id="program5" class="program-code">
         Q1 import nltk
            from nltk.stem import WordNetLemmatizer
            from nltk.corpus import wordnet
            nltk.download('wordnet')
            nltk.download('omw-1.4')
            lema=WordNetLemmatizer()
            words=["swimming","better","running","studies","leaves","am","car"]
            print("lemmatizaion result")
            for word in words:
                 print(f"{word}--->{lema.lemmatize(word)}")
            print("\n Lemmatization with POS tags")
            for word in ["swimming","better","running","leaves"]:
                print(f"{word} (verb)---->(lema.lemmatize(word,pos='v')}")
            
        Q2 #bfs
            from collections import deque
            def bfs(graph,root,goal):
               visited=set()
               queue=deque([root])
               visited.add(root)

            while queue:
                vertex=queue.popleft()
                print(vertex,end=" ")
                if vertex==goal:
                   print("goal found")
                   return

                for neighbour in graph.get(vertex,[]):
                     if neighbour not in visited:
                         visited.add(neighbour)
                          queue.append(neighbour)

            graph={
            '1':['2','3'],
            '2':['4','5'],
            '3':['6','7'],
            '4':['8'],
            '5':['8'],
            '6':['8'],
            '7':['8'],
            '8':[],
    }
            bfs(graph,'2','8')
           
        </textarea>
        
        <button id="btn-program5" onclick="copyProgram('program5', 'btn-program5')">slip5</button>
    </div>    
    
    <div class="program-section">
        <h2 class="program-title"></h2>
        
        <textarea id="program6" class="program-code">
        Q1    from nltk.tokenize import sent_tokenize, word_tokenize
            from nltk.corpus import stopwords
            import nltk
            
            nltk.download('stopwords')
            nltk.download('punkt')
            nltk.download('punkt_tab')

            paragraph=""" The boy is playing in the garden with his frds . It is a bright and sunny day , and children are happy to be outside """
            words=word_tokenize(paragraph)
            stop_word=set(stopwords.words('english'))
            filtered_words=[word for word in words if word.lower() not in stop_word and word.isalpha()]
            filtered_paragraph=' '.join(filtered_words)
            print("original paragraph ",paragraph)
            print("filtered paragraph without stopwords ",filtered_paragraph)
         
        Q2  #bfs
            from collections import deque
            def bfs(graph,root,goal):
               visited=set()
               queue=deque([root])
               visited.add(root)

            while queue:
                vertex=queue.popleft()
                print(vertex,end=" ")
                if vertex==goal:
                   print("goal found")
                   return

                for neighbour in graph.get(vertex,[]):
                     if neighbour not in visited:
                         visited.add(neighbour)
                          queue.append(neighbour)

            graph={
            '1':['2','3'],
            '2':['4','5'],
            '3':['6','7'],
            '4':['8'],
            '5':['8'],
            '6':['8'],
            '7':['8'],
            '8':[],
    }
            bfs(graph,'2','8')
        
           
        </textarea>
        
        <button id="btn-program6" onclick="copyProgram('program6', 'btn-program6')">slip6</button>
    </div>    
    
    <div class="program-section">
        <h2 class="program-title"></h2>
        
        <textarea id="program7" class="program-code">
    Q1  pip install easyAI
    from easyAI import TwoPlayerGame
    from easyAI.Player import Human_Player
    class TicTacToe(TwoPlayerGame):
    """The board positions are numbered as follows:
     1 2 3
     4 5 6
     7 8 9
     """
    def __init__(self, players):
    self.players = players
    self.board = [0 for i in range(9)]
    self.current_player = 1 # player 1 starts.
    def possible_moves(self):
 return [i + 1 for i, e in enumerate(self.board) if e == 0]
 def make_move(self, move):
self.board[int(move) - 1] = self.current_player
def unmake_move(self, move): # optional method (speeds up the AI)
self.board[int(move) - 1] = 0
def lose(self):
""" Has the opponent "three in line ?" """
return any(
 [
all([(self.board[c - 1] == self.opponent_index) for c 
in line])
for line in [
 [1, 2, 3],
 [4, 5, 6],
 [7, 8, 9], # horiz.
 [1, 4, 7],
 [2, 5, 8],
 [3, 6, 9], # vertical
 [1, 5, 9],
 [3, 5, 7],
 ]
 ]
 ) # diagonal
def is_over(self):
return (self.possible_moves() == []) or self.lose()
def show(self):
print(
"\n"
 + "\n".join(
 [
" ".join([[".", "O", "X"][self.board[3 * j + i]] 
for i in range(3)])
for j in range(3)
 ]
 )
 )
def scoring(self):
return -100 if self.lose() else 0
if __name__ == "__main__":
from easyAI import AI_Player, Negamax
 ai_algo = Negamax(6)
 TicTacToe([Human_Player(), AI_Player(ai_algo)]).play()

Slip 7-2 : Q.2) Write a Python program to implement Simple Chatbot. [ 20Marks ]


def chatbot_response(user_input):
    user_input = user_input.lower()

    if "hello" in user_input or "hi" in user_input:
        return "Hello! How can I help you?"
    elif "how are you" in user_input:
        return "I'm just a chatbot, but I'm doing great! How about you?"
    elif "your name" in user_input:
        return "I'm a simple Python chatbot."
    elif "time" in user_input:
        from datetime import datetime
        return "The current time is " + datetime.now().strftime("%H:%M:%S")
    elif "bye" in user_input:
        return "Goodbye! Have a nice day!"
    else:
        return "I'm not sure I understand what you mean."


def main():
    print("ğŸ¤– Simple Chatbot")
    print("Type 'bye' to exit.\n")

    while True:
        user_input = input("You: ")
        if "bye" in user_input.lower():
            print("Chatbot: Goodbye! ğŸ‘‹")
            break
        response = chatbot_response(user_input)
        print("Chatbot:", response)


if _name_ == "_main_":
    main()
        </textarea>
        
        <button id="btn-program7" onclick="copyProgram('program7', 'btn-program7')">slip7</button>
    </div>    
    
    <div class="program-section">
        <h2 class="program-title"></h2>
        
        <textarea id="program8" class="program-code">
    Q1 Str = input("Enter a string: ")
    lower=0
    upper=0
    for i in Str:
    if(i.islower()):
     lower+=1
    else:
     upper+=1
    print("The number of lowercase characters is:",lower)
    print("The number of uppercase characters is:",upper)
    
    Q2  pip install easyAI
    from easyAI import TwoPlayerGame
    from easyAI.Player import Human_Player
    class TicTacToe(TwoPlayerGame):
    """The board positions are numbered as follows:
     1 2 3
     4 5 6
     7 8 9
     """
    def __init__(self, players):
    self.players = players
    self.board = [0 for i in range(9)]
    self.current_player = 1 # player 1 starts.
    def possible_moves(self):
 return [i + 1 for i, e in enumerate(self.board) if e == 0]
 def make_move(self, move):
self.board[int(move) - 1] = self.current_player
def unmake_move(self, move): # optional method (speeds up the AI)
self.board[int(move) - 1] = 0
def lose(self):
""" Has the opponent "three in line ?" """
return any(
 [
all([(self.board[c - 1] == self.opponent_index) for c 
in line])
for line in [
 [1, 2, 3],
 [4, 5, 6],
 [7, 8, 9], # horiz.
 [1, 4, 7],
 [2, 5, 8],
 [3, 6, 9], # vertical
 [1, 5, 9],
 [3, 5, 7],
 ]
 ]
 ) # diagonal
def is_over(self):
return (self.possible_moves() == []) or self.lose()
def show(self):
print(
"\n"
 + "\n".join(
 [
" ".join([[".", "O", "X"][self.board[3 * j + i]] 
for i in range(3)])
for j in range(3)
 ]
 )
 )
def scoring(self):
return -100 if self.lose() else 0
if __name__ == "__main__":
from easyAI import AI_Player, Negamax
 ai_algo = Negamax(6)
 TicTacToe([Human_Player(), AI_Player(ai_algo)]).play()
        </textarea>
        
        <button id="btn-program8" onclick="copyProgram('program8', 'btn-program8')">slip8</button>
    </div>    
    
    <div class="program-section">
        <h2 class="program-title"></h2>
        
        <textarea id="program9" class="program-code">
    Q1 import heapq
    class PuzzleNode:
    Â  Â  def __init__(self, state, parent=None, move=None, depth=0):
    Â  Â  Â  Â  self.state = state
    Â  Â  Â  Â  self.parent = parent
    Â  Â  Â  Â  self.move = move
    Â  Â  Â  Â  self.depth = depth
    Â  Â  Â  Â  self.cost = self.depth + self.heuristic()
    Â  Â  def __lt__(self, other):
    Â  Â  Â  Â  return self.cost < other.cost
    Â  Â  def heuristic(self):
    Â  Â  Â  Â  goal = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
    Â  Â  Â  Â  distance = 0
    Â  Â  Â  Â  for i in range(3):
    Â  Â  Â  Â  Â  Â  for j in range(3):
    Â  Â  Â  Â  Â  Â  Â  Â  value = self.state[i][j]
    Â  Â  Â  Â  Â  Â  Â  Â  if value != 0:
    Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  goal_row, goal_col = divmod(value - 1, 3)
    Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  distance += abs(i - goal_row) + abs(j - goal_col)
    Â  Â  Â  Â  return distance
    Â  Â  def get_neighbors(self):
    Â  Â  Â  Â  neighbors = []
    Â  Â  Â  Â  zero_row, zero_col = [(i, row.index(0)) for i, row in
    enumerate(self.state) if 0 in row][0]
    Â  Â  Â  Â  moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    Â  Â  Â  Â  for move in moves:
    Â  Â  Â  Â  Â  Â  new_row, new_col = zero_row + move[0], zero_col + move[1]
    Â  Â  Â  Â  Â  Â  if 0 <= new_row < 3 and 0 <= new_col < 3:
    Â  Â  Â  Â  Â  Â  Â  Â  new_state = [row[:] for row in self.state]
    Â  Â  Â  Â  Â  Â  Â  Â  new_state[zero_row][zero_col], new_state[new_row]
    [new_col] = new_state[new_row][new_col], new_state[zero_row][zero_col]
    Â  Â  Â  Â  Â  Â  Â  Â  neighbors.append(PuzzleNode(new_state, self, move, 
    self.depth + 1))
    Â  Â  Â  Â  return neighbors
    Â  Â  def print_path(self):
    Â  Â  Â  Â  if self.parent:
    Â  Â  Â  Â  Â  Â  self.parent.print_path()
    Â  Â  Â  Â  print(f"Move {self.move}:")
    Â  Â  Â  Â  print(self)
    Â  Â  def __str__(self):
    Â  Â  Â  Â  return "\n".join(" ".join(map(str, row)) for row in self.state)
    def solve_8_puzzle(initial_state):
    Â  Â  initial_node = PuzzleNode(initial_state)
    Â  Â  goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
    Â  Â  # A* search (using a priority queue)
    Â  Â  heap = [initial_node]
    Â  Â  visited = set()
    Â  Â  while heap:
    Â  Â  Â  Â  current_node = heapq.heappop(heap)
    Â  Â  Â  Â  if current_node.state == goal_state:
    Â  Â  Â  Â  Â  Â  current_node.print_path()
    Â  Â  Â  Â  Â  Â  return
    Â  Â  Â  Â  visited.add(tuple(map(tuple, current_node.state)))
    Â  Â  Â  Â  for neighbor in current_node.get_neighbors():
    
    Â  Â  Â  Â  Â  Â  if tuple(map(tuple, neighbor.state)) not in visited:
    Â  Â  Â  Â  Â  Â  Â  Â  heapq.heappush(heap, neighbor)
    Â  Â  print("No solution found.")
    # Example usage
    initial_puzzle = [[1, 2, 3], [4, 5, 6], [0, 7, 8]] Â # Initial state
    solve_8_puzzle(initial_puzzle)

    Q2 bfs_queue = [(0, 0, None, 0)] # 4_jug, 3_jug, parent state, rule 
    applied
    visited_states = [] #all the states which are not to be considered for 
    exploration
    output_path = [] #to print the path
    print ("Enter Jug 1 Capacity, Jug 2 Capacity, Target (space separated)\
    n : "),
    jug1, jug2, target = map(int, input().split())
    print ("\nInitial State. -> (0, 0)")
    print ("Goal State. -> (%d, N) or (M, %d) \n"%(target, target))
    # Production rules
    def success(M, N) :
     global target
     return M == target or N == target
    def fill_M(M, N) :
     global jug1
     if M < jug1 :
     M = jug1
     return M, N, 1
    def fill_N(M, N) :
     global jug2
     if N < jug2 :
     N = jug2
     return M, N, 2
    def empty_M(M, N) :
     if M > 0 :
     M = 0
     return M, N, 3
    def empty_N(M, N) :
     if N > 0 :
     N = 0
     return M, N, 4
    def pour_N_to_M(M, N) :
     global jug1
     if N > 0 and M + N >= jug1 :
     M = jug1
     N = N - (jug1 - M)
     return M, N, 5
    def pour_M_to_N(M, N) :
     global jug2
     if M > 0 and M + N >= jug2 :
     M = M - (jug2 - N)
     N = jug2
     return M, N, 6
    def pour_all_N_to_M(M, N) :
     global jug1
     if M + N <= jug1 and N > 0 :
     M = M + N
     N = 0
     return M, N, 7
    def pour_all_M_to_N(M, N) :
     global jug2
     if M + N <= jug2 and M > 0 :
     N = N + M
     M = 0
     return M, N, 8
    #----------------------------------
    # chekcing if the state has been visited
    def state_visited(x, y) :
     for val in visited_states :
     if val[0] == x and val[1] == y :
     return True
     return False
    if __name__ == '__main__' :
     rules = [fill_M, fill_N, empty_M, empty_N,
     pour_N_to_M, pour_M_to_N, pour_all_N_to_M, pour_all_M_to_N] 
    #function list
     rule_text = ["1. Fill the {}-gallon jug.".format(jug1), "2. Fill 
    the {}-gallon jug.".format(jug2),
     "3. Empty {}-gallon jug.".format(jug1), "4. Empty {}-gallon 
    jug.".format(jug2),
     "5. Pour water from {}-gallon to {}-gallon jug.".format(jug2, 
    jug1),
     "6. Pour water from {}-gallon to {}-gallon jug.".format(jug1, 
    jug2),
     "7. Pour all the water from {}-gallon to {}-gallon 
    jug.".format(jug2, jug1),
     "8. Pour all the water from {}-gallon to {}-gallon 
    jug.".format(jug1, jug2)]
     done = False
     #Approach using breadth first search
     while bfs_queue :
     M, N, parent, rule_no = bfs_queue.pop(0)
     visited_states.append((M, N, parent, rule_no))
     for func in rules : #applying all the rules to the current 
    state
     x, y, rule_no = func(M, N)
     if x < 0 or y < 0 :
     continue
     if success(x, y) :
     done = True
     visited_states.append((x, y, (M, N), rule_no))
     break
     if not state_visited(x, y) : #appending the newly formed 
    states in the queue
     bfs_queue.append((x, y, (M, N), rule_no))
     if done :
     print ("\nGOAL Reached!")
     break
     #end_while
     if not done :
     print ("No Solution Exists!")
     print ("Terminated.")
     exit(0)
     index = len(visited_states) - 1
     output_path.append((visited_states[index][:2], None))
     parent = visited_states[index][2]
     rule = visited_states[index][3]
     # finding the path from bottom to top
     while parent :
     output_path.append((parent, rule))
     for val in visited_states :
     if val[0] == parent[0] and val[1] == parent[1] :
     parent = val[2]
     rule = val[3]
     break
     op = list(reversed(output_path))
     #printing the states and the rules applied.
     for i in range(0, len(op)) :
     if op[i][1] is not None :
     print (op[i][0], " -> ", rule_text[op[i][1] - 1])
     print (op[len(op) - 1][0], " -> Goal State.")
     print ("Terminated.")

        </textarea>
        
        <button id="btn-program9" onclick="copyProgram('program9', 'btn-program9')">slip9</button>
    </div>    
    

    <div class="program-section">
        <h2 class="program-title"></h2>
        
        <textarea id="program10" class="program-code">
    Q1 from itertools import permutations
    def cryptarithmetic():
    Â  Â  # All possible digits (0 to 9)
    Â  Â  digits = range(10)
    Â  Â  
    Â  Â  # All the letters involved
    Â  Â  letters = 'TWOFRU'
    Â  Â  
    Â  Â  # Generate all possible permutations of digits for the 6 letters
    Â  Â  for perm in permutations(digits, len(letters)):
    Â  Â  Â  Â  # Create a mapping of letters to digits
    Â  Â  Â  Â  letter_to_digit = dict(zip(letters, perm))
    Â  Â  Â  Â  
    Â  Â  Â  Â  # Get the numbers corresponding to TWO, TWO, and FOUR
    Â  Â  Â  Â  TWO = letter_to_digit['T'] * 100 + letter_to_digit['W'] * 10 +
    letter_to_digit['O']
    Â  Â  Â  Â  FOUR = letter_to_digit['F'] * 1000 + letter_to_digit['O'] * 100
    + letter_to_digit['U'] * 10 + letter_to_digit['R'] 
    Â  Â  Â  Â  
    Â  Â  Â  Â  # Check if TWO + TWO equals FOUR
    Â  Â  Â  Â  if TWO + TWO == FOUR:
    Â  Â  Â  Â  Â  Â  # If the equation is satisfied, print the solution
    Â  Â  Â  Â  Â  Â  print(f"TWO + TWO = FOUR")
    Â  Â  Â  Â  Â  Â  print(f"{TWO} + {TWO} = {FOUR}")
    Â  Â  Â  Â  Â  Â  print(f"Letter to digit mapping: {letter_to_digit}")
    Â  Â  Â  Â  Â  Â  return
    Â  Â  print("No solution found.")
    if __name__ == "__main__":
    Â  Â  cryptarithmetic()

    Q.2
    import random
    def simple_chatbot():
    Â  Â  responses = {
    Â  Â  Â  Â  "hello": ["Hi there!", "Hello!", "Hey!"],
    Â  Â  Â  Â  "how are you": ["I'm good, thanks!", "I'm doing well.", "All 
    good!"],
    Â  Â  Â  Â  "bye": ["Goodbye!", "See you later!", "Bye!"],
    Â  Â  Â  Â  "default": ["I'm not sure how to respond.", "Could you say that
    again?", "Sorry, I didn't get that."]
    Â  Â  }
    Â  Â  
    Â  Â  print("Simple Chatbot: Hi! Type 'bye' to exit.")
    Â  Â  
    Â  Â  while True:
    Â  Â  Â  Â  user_input = input("You: ").lower()
    Â  Â  Â  Â  
    Â  Â  Â  Â  if user_input == 'bye':
    Â  Â  Â  Â  Â  Â  print("Simple Chatbot: Goodbye!")
    Â  Â  Â  Â  Â  Â  break
    Â  Â  Â  Â  else:
    Â  Â  Â  Â  Â  Â  response = responses.get(user_input, responses["default"])
    Â  Â  Â  Â  Â  Â  print("Simple Chatbot:", random.choice(response))
    if __name__ == "__main__":
    Â  Â  simple_chatbot()
    
        </textarea>
        
        <button id="btn-program10" onclick="copyProgram('program10', 'btn-program10')">slip10</button>
    </div>    
    

    <div class="program-section">
        <h2 class="program-title"></h2>
        
        <textarea id="program11" class="program-code">
    Q1 def mean_end_analysis(start_str, target_str):
    Â  Â  current_str = start_str
    Â  Â  target_str_len = len(target_str)
    Â  Â  steps = [] Â # List to store the transformation steps
    Â  Â  # Continue until the current string matches the target string
    Â  Â  while current_str != target_str:
    Â  Â  Â  Â  print(f"Current string: {current_str}")
    Â  Â  Â  Â  print(f"Target string: {target_str}")
    Â  Â  Â  Â  # If the current string is shorter than the target, insert 
    characters
    Â  Â  Â  Â  if len(current_str) < target_str_len:
    Â  Â  Â  Â  Â  Â  # Insert characters from the target string
    Â  Â  Â  Â  Â  Â  for i in range(len(current_str), target_str_len):
    Â  Â  Â  Â  Â  Â  Â  Â  current_str += target_str[i] Â # Add the next character 
    from target to current_str
    Â  Â  Â  Â  Â  Â  Â  Â  steps.append(f"Insert '{target_str[i]}' at position 
    {i+1}")
    Â  Â  Â  Â  Â  Â  Â  Â  break Â # Insert one character at a time and then break 
    out
    Â  Â  Â  Â  # If the current string is longer than the target, delete extra
    characters
    Â  Â  Â  Â  elif len(current_str) > target_str_len:
    Â  Â  Â  Â  Â  Â  current_str = current_str[:-1] Â # Remove last character
    Â  Â  Â  Â  Â  Â  steps.append(f"Delete character '{current_str[-1]}'")
    Â  Â  Â  Â  # If characters at the same position are different, replace 
    them
    Â  Â  Â  Â  else:
    Â  Â  Â  Â  Â  Â  for i in range(len(current_str)):
    Â  Â  Â  Â  Â  Â  Â  Â  if current_str[i] != target_str[i]:
    Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  current_str = current_str[:i] + target_str[i] +
    current_str[i+1:]
    Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  steps.append(f"Replace '{current_str[i]}' with 
    '{target_str[i]}' at position {i+1}")
    Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break
    Â  Â  # Final output
    Â  Â  print(f"\nFinal transformed string: {current_str}")
    Â  Â  print(f"Steps taken:")
    Â  Â  for step in steps:
    Â  Â  Â  Â  print(step)
    if __name__ == "__main__":
    Â  Â  # Example input: Transform "kitten" to "sitting"
    Â  Â  start_str = "kitten"
    Â  Â  target_str = "sitting"
    Â  Â  mean_end_analysis(start_str, target_str)

    Q.2
    from collections import deque
    def water_jug_problem(capacity1, capacity2, target):
    Â  Â  visited = set()
    Â  Â  queue = deque([(0, 0)])
    Â  Â  parent_map = { (0, 0): None }
    Â  Â  operations = [
    Â  Â  Â  Â  ("Fill Jug 1", lambda x, y: (capacity1, y)),
    Â  Â  Â  Â  ("Fill Jug 2", lambda x, y: (x, capacity2)),
    Â  Â  Â  Â  ("Empty Jug 1", lambda x, y: (0, y)),
    Â  Â  Â  Â  ("Empty Jug 2", lambda x, y: (x, 0)),
    Â  Â  Â  Â  ("Pour Jug 1 into Jug 2", lambda x, y: (x - min(x, capacity2 -
    y), y + min(x, capacity2 - y))),
    Â  Â  Â  Â  ("Pour Jug 2 into Jug 1", lambda x, y: (x + min(y, capacity1 -
    x), y - min(y, capacity1 - x)))
    Â  Â  ]
    Â  Â  
    Â  Â  while queue:
    Â  Â  Â  Â  x, y = queue.popleft()
    Â  Â  Â  Â  if y == target:
    Â  Â  Â  Â  Â  Â  solution = []
    Â  Â  Â  Â  Â  Â  while (x, y) != (0, 0):
    Â  Â  Â  Â  Â  Â  Â  Â  prev_x, prev_y = parent_map[(x, y)]
    Â  Â  Â  Â  Â  Â  Â  Â  for op_name, op_func in operations:
    Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if op_func(prev_x, prev_y) == (x, y):
    Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  solution.append(op_name)
    Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break
    Â  Â  Â  Â  Â  Â  Â  Â  x, y = prev_x, prev_y
    Â  Â  Â  Â  Â  Â  solution.reverse()
    Â  Â  Â  Â  Â  Â  return solution
    Â  Â  Â  Â  
    Â  Â  Â  Â  for op_name, op_func in operations:
    Â  Â  Â  Â  Â  Â  new_x, new_y = op_func(x, y)
    Â  Â  Â  Â  Â  Â  if (new_x, new_y) not in visited:
    Â  Â  Â  Â  Â  Â  Â  Â  visited.add((new_x, new_y))
    Â  Â  Â  Â  Â  Â  Â  Â  parent_map[(new_x, new_y)] = (x, y)
    Â  Â  Â  Â  Â  Â  Â  Â  queue.append((new_x, new_y))
    Â  Â  
    Â  Â  return None
    capacity1 = 4
    capacity2 = 3
    target = 2
    solution = water_jug_problem(capacity1, capacity2, target)
    if solution:
    Â  Â  print("Steps to reach the goal:")
    Â  Â  for step in solution:
    Â  Â  Â  Â  print(step)
    else:
    Â  Â  print("No solution exists")
    
        </textarea>
        
        <button id="btn-program11" onclick="copyProgram('program11', 'btn-program11')">slip11</button>
    </div>    
    

    <div class="program-section">
        <h2 class="program-title"></h2>
        
        <textarea id="program12" class="program-code">
     Q1 
            import calendar
     y = int(input("Input the year : "))
     m = int(input("Input the month : "))
     print("your calendar:")
     print(calendar.month(y, m))

     Q.2
     def is_safe(board, row, col):
     Â  Â  for i in range(row):
     Â  Â  Â  Â  if board[i] == col or board[i] - i == col - row or board[i] + i
     == col + row:
     Â  Â  Â  Â  Â  Â  return False
     Â  Â  return True
     def solve_4_queens(board, row, solutions):
     Â  Â  if row == len(board):
     Â  Â  Â  Â  solutions.append(board[:])
     Â  Â  Â  Â  return
     Â  Â  for col in range(len(board)):
     Â  Â  Â  Â  if is_safe(board, row, col):
     Â  Â  Â  Â  Â  Â  board[row] = col
     Â  Â  Â  Â  Â  Â  solve_4_queens(board, row + 1, solutions)
     Â  Â  Â  Â  Â  Â  board[row] = -1
     def print_solutions(solutions):
     Â  Â  for solution in solutions:
     Â  Â  Â  Â  print("Solution:")
     Â  Â  Â  Â  for row in solution:
     Â  Â  Â  Â  Â  Â  board_row = ['Q' if i == row else '.' for i in
     range(len(solution))]
     Â  Â  Â  Â  Â  Â  print(" ".join(board_row))
     Â  Â  Â  Â  print()
     def main():
     Â  Â  n = 4
     Â  Â  board = [-1] * n
     Â  Â  solutions = []
     Â  Â  solve_4_queens(board, 0, solutions)
     Â  Â  print_solutions(solutions)
     if __name__ == "__main__":
     Â  Â  main()
     
        </textarea>
        
        <button id="btn-program12" onclick="copyProgram('program12', 'btn-program12')">slip12</button>
    </div>    
    


    <div class="program-section">
        <h2 class="program-title"></h2>
        
        <textarea id="program13" class="program-code">
    
Q1  import math
PLAYER_X = 1
PLAYER_O = -1
EMPTY = 0
def print_board(board):
Â  Â  for row in board:
Â  Â  Â  Â  print(" | ".join(str(cell) if cell != EMPTY else " " for cell
in row))
Â  Â  Â  Â  print("---------")
def check_winner(board, player):
Â  Â  for row in range(3):
Â  Â  Â  Â  if all([board[row][col] == player for col in range(3)]): return
True
Â  Â  for col in range(3):
Â  Â  Â  Â  if all([board[row][col] == player for row in range(3)]): return
True
Â  Â  if all([board[i][i] == player for i in range(3)]): return True
Â  Â  if all([board[i][2-i] == player for i in range(3)]): return True
Â  Â  return False
def is_game_over(board):
Â  Â  return check_winner(board, PLAYER_X) or check_winner(board, 
PLAYER_O) or all(cell != EMPTY for row in board for cell in row)
def evaluate(board):
Â  Â  if check_winner(board, PLAYER_X): return 1
Â  Â  if check_winner(board, PLAYER_O): return -1
Â  Â  return 0
def available_moves(board):
Downloaded by Datir Sanskruti (sanskrutidatir528@gmail.com)
lOMoARcPSD|59303612
Â  Â  return [(row, col) for row in range(3) for col in range(3) if
board[row][col] == EMPTY]
def minimax(board, is_maximizing_player):
Â  Â  if is_game_over(board): return evaluate(board)
Â  Â  
Â  Â  if is_maximizing_player:
Â  Â  Â  Â  best = -math.inf
Â  Â  Â  Â  for row, col in available_moves(board):
Â  Â  Â  Â  Â  Â  board[row][col] = PLAYER_X
Â  Â  Â  Â  Â  Â  best = max(best, minimax(board, False))
Â  Â  Â  Â  Â  Â  board[row][col] = EMPTY
Â  Â  Â  Â  return best
Â  Â  else:
Â  Â  Â  Â  best = math.inf
Â  Â  Â  Â  for row, col in available_moves(board):
Â  Â  Â  Â  Â  Â  board[row][col] = PLAYER_O
Â  Â  Â  Â  Â  Â  best = min(best, minimax(board, True))
Â  Â  Â  Â  Â  Â  board[row][col] = EMPTY
Â  Â  Â  Â  return best
def find_best_move(board):
Â  Â  best_val = -math.inf
Â  Â  best_move = None
Â  Â  for row, col in available_moves(board):
Â  Â  Â  Â  board[row][col] = PLAYER_X
Â  Â  Â  Â  move_val = minimax(board, False)
Â  Â  Â  Â  board[row][col] = EMPTY
Â  Â  Â  Â  if move_val > best_val:
Â  Â  Â  Â  Â  Â  best_val = move_val
Â  Â  Â  Â  Â  Â  best_move = (row, col)
Â  Â  return best_move
def play_game():
Â  Â  board = [[EMPTY for _ in range(3)] for _ in range(3)]
Â  Â  while not is_game_over(board):
Â  Â  Â  Â  print_board(board)
Â  Â  Â  Â  if sum(row.count(PLAYER_X) for row in board) <=
sum(row.count(PLAYER_O) for row in board):
Â  Â  Â  Â  Â  Â  row, col = find_best_move(board)
Â  Â  Â  Â  Â  Â  board[row][col] = PLAYER_X
Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  row, col = find_best_move(board)
Â  Â  Â  Â  Â  Â  board[row][col] = PLAYER_O
Â  Â  print_board(board)
Â  Â  if check_winner(board, PLAYER_X):
Â  Â  Â  Â  print("Player X wins!")
Â  Â  elif check_winner(board, PLAYER_O):
Â  Â  Â  Â  print("Player O wins!")
Â  Â  else:
Â  Â  Â  Â  print("It's a draw!")
Downloaded by Datir Sanskruti (sanskrutidatir528@gmail.com)
lOMoARcPSD|59303612
play_game()
Q.2) Write a Python program to simulate 8-Queens problem.
def print_solution(board):
Â  Â  for row in board:
Â  Â  Â  Â  print(" ".join("Q" if x else "." for x in row))
def is_safe(board, row, col):
Â  Â  for i in range(row):
Â  Â  Â  Â  if board[i][col] == 1:
Â  Â  Â  Â  Â  Â  return False
Â  Â  Â  Â  if col - (row - i) >= 0 and board[i][col - (row - i)] == 1:
Â  Â  Â  Â  Â  Â  return False
Â  Â  Â  Â  if col + (row - i) < len(board) and board[i][col + (row - i)] 
== 1:
Â  Â  Â  Â  Â  Â  return False
Â  Â  return True
def solve_n_queens(board, row):
Â  Â  if row == len(board):
Â  Â  Â  Â  print_solution(board)
Â  Â  Â  Â  return True
Â  Â  
Â  Â  for col in range(len(board)):
Â  Â  Â  Â  if is_safe(board, row, col):
Â  Â  Â  Â  Â  Â  board[row][col] = 1
Â  Â  Â  Â  Â  Â  if solve_n_queens(board, row + 1):
Â  Â  Â  Â  Â  Â  Â  Â  return True
Â  Â  Â  Â  Â  Â  board[row][col] = 0
Â  Â  return False
def n_queens(n):
Â  Â  board = [[0 for _ in range(n)] for _ in range(n)]
Â  Â  solve_n_queens(board, 0)
n_queens(8)

</textarea>
        
<button id="btn-program13" onclick="copyProgram('program13', 'btn-program13')">slip13</button>
</div>      


<div class="program-section">
    <h2 class="program-title"></h2>
    
    <textarea id="program14" class="program-code">
Q1 def sort_sentence(sentence):
Â  Â  words = sentence.split()
Â  Â  words.sort()
Â  Â  return " ".join(words)
sentence = "the quick brown fox jumps over the lazy dog"
sorted_sentence = sort_sentence(sentence)
print(sorted_sentence)

Q.2
def print_solution(board):
Â  Â  for row in board:
Â  Â  Â  Â  print(" ".join("Q" if x else "." for x in row))
def is_safe(board, row, col):
Â  Â  for i in range(row):
Â  Â  Â  Â  if board[i][col] == 1:
Â  Â  Â  Â  Â  Â  return False
Â  Â  Â  Â  if col - (row - i) >= 0 and board[i][col - (row - i)] == 1:
Â  Â  Â  Â  Â  Â  return False
Â  Â  Â  Â  if col + (row - i) < len(board) and board[i][col + (row - i)] 
== 1:
Â  Â  Â  Â  Â  Â  return False
Â  Â  return True
def solve_n_queens(board, row):
Â  Â  if row == len(board):
Â  Â  Â  Â  print_solution(board)
Â  Â  Â  Â  return True
Â  Â  
Â  Â  for col in range(len(board)):
Â  Â  Â  Â  if is_safe(board, row, col):
Â  Â  Â  Â  Â  Â  board[row][col] = 1
Â  Â  Â  Â  Â  Â  if solve_n_queens(board, row + 1):
Â  Â  Â  Â  Â  Â  Â  Â  return True
Â  Â  Â  Â  Â  Â  board[row][col] = 0
Â  Â  return False
def n_queens(n):
Â  Â  board = [[0 for _ in range(n)] for _ in range(n)]
Â  Â  solve_n_queens(board, 0)
n_queens(8)
    </textarea>
    
    <button id="btn-program14" onclick="copyProgram('program14', 'btn-program14')">slip14</button>
</div>    

<div class="program-section">
    <h2 class="program-title"></h2>
    
    <textarea id="program15" class="program-code">
      Q1  Â  Â  def __init__(self):
        Â  Â  Â  Â  self.monkey_position = 'ground'
        Â  Â  Â  Â  self.box_position = 'floor'
        Â  Â  Â  Â  self.banana_position = 'high_shelf'
        Â  Â  Â  Â  self.monkey_has_banana = False
        Â  Â  def push_box(self):
        Â  Â  Â  Â  if self.box_position == 'floor':
        Â  Â  Â  Â  Â  Â  print("Monkey pushes the box to reach the shelf.")
        Â  Â  Â  Â  Â  Â  self.box_position = 'near_banana'
        Â  Â  def climb_box(self):
        Â  Â  Â  Â  if self.box_position == 'near_banana':
        Â  Â  Â  Â  Â  Â  print("Monkey climbs the box.")
        Â  Â  Â  Â  Â  Â  self.monkey_position = 'on_box'
        Â  Â  def reach_banana(self):
        Â  Â  Â  Â  if self.monkey_position == 'on_box':
        Â  Â  Â  Â  Â  Â  print("Monkey grabs the banana from the shelf!")
        Â  Â  Â  Â  Â  Â  self.monkey_has_banana = True
        Â  Â  def perform_actions(self):
        Â  Â  Â  Â  print("Monkey is on the ground.")
        Â  Â  Â  Â  self.push_box()
        Â  Â  Â  Â  self.climb_box()
        Â  Â  Â  Â  self.reach_banana()
        # Run the simulation
        monkey_problem = MonkeyBanana()
        monkey_problem.perform_actions()

        Q.2
        class IterativeDeepeningDFS:
        Â  Â  def __init__(self, graph, start, goal):
        Â  Â  Â  Â  self.graph = graph
        Â  Â  Â  Â  self.start = start
        Â  Â  Â  Â  self.goal = goal
        Â  Â  def dfs(self, node, depth, visited):
        Â  Â  Â  Â  if depth == 0:
        Â  Â  Â  Â  Â  Â  if node == self.goal:
        Â  Â  Â  Â  Â  Â  Â  Â  return [node]
        Â  Â  Â  Â  Â  Â  return None
        Â  Â  Â  Â  if depth > 0:
        Â  Â  Â  Â  Â  Â  visited.add(node)
        Â  Â  Â  Â  Â  Â  for neighbor in self.graph.get(node, []):
        Â  Â  Â  Â  Â  Â  Â  Â  if neighbor not in visited:
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  path = self.dfs(neighbor, depth - 1, visited)
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if path:
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return [node] + path
        Â  Â  Â  Â  return None
        Â  Â  def iddfs(self):
        Â  Â  Â  Â  depth = 0
        Â  Â  Â  Â  while True:
        Â  Â  Â  Â  Â  Â  visited = set()
        Â  Â  Â  Â  Â  Â  result = self.dfs(self.start, depth, visited)
        Â  Â  Â  Â  Â  Â  if result:
        Â  Â  Â  Â  Â  Â  Â  Â  return result
        Â  Â  Â  Â  Â  Â  depth += 1
        # Example usage:
        # Graph provided by the user
        graph = {
        Â  Â  'A': ['B', 'C'],
        Â  Â  'B': ['D', 'E'],
        Â  Â  'C': ['F', 'G'],
        Â  Â  'D': ['H', 'I'],
        Â  Â  'E': ['G'],
        Â  Â  'F': ['K'],
        Â  Â  'G': []
        }
        # Goal is to find node 'G' starting from node 'A'
        iddfs = IterativeDeepeningDFS(graph, 'A', 'G')
        path = iddfs.iddfs()
        if path:
        Â  Â  print(f"Path to goal: {' -> '.join(path)}")
        else:
        Â  Â  print("Goal not found.")
    
    </textarea>
    
    <button id="btn-program15" onclick="copyProgram('program15', 'btn-program15')">slip15</button>
</div>    


<div class="program-section">
    <h2 class="program-title"></h2>
    
    <textarea id="program16" class="program-code">
    Q1  def tower_of_hanoi(n, source, destination, auxiliary):
        Â  Â  if n == 1:
        Â  Â  Â  Â  print(f"Move disk 1 from {source} to {destination}")
        Â  Â  Â  Â  return
        Â  Â  tower_of_hanoi(n-1, source, auxiliary, destination)
        Â  Â  print(f"Move disk {n} from {source} to {destination}")
        Â  Â  tower_of_hanoi(n-1, auxiliary, destination, source)
        if __name__ == "__main__":
        Â  Â  n = int(input("Enter the number of disks: "))
        Â  Â  tower_of_hanoi(n, 'A', 'C', 'B')

        Q.2
        def print_board(board):
        Â  Â  for row in board:
        Â  Â  Â  Â  print(" | ".join(row))
        Â  Â  Â  Â  print("-" * 5)
        def check_winner(board, player):
        Â  Â  for i in range(3):
        Â  Â  Â  Â  if all([board[i][j] == player for j in range(3)]) or
        all([board[j][i] == player for j in range(3)]):
        Â  Â  Â  Â  Â  Â  return True
        Â  Â  if board[0][0] == player and board[1][1] == player and board[2][2] 
        == player:
        Â  Â  Â  Â  return True
        Â  Â  if board[0][2] == player and board[1][1] == player and board[2][0] 
        == player:
        Â  Â  Â  Â  return True
        Â  Â  return False
        def is_full(board):
        Â  Â  return all([board[i][j] != " " for i in range(3) for j in
        range(3)])
        def play_game():
        Â  Â  board = [[" " for _ in range(3)] for _ in range(3)]
        Â  Â  current_player = "X"
        Â  Â  while True:
        Â  Â  Â  Â  print_board(board)
        Â  Â  Â  Â  try:
        Â  Â  Â  Â  Â  Â  row = int(input("Enter row (0, 1, or 2): "))
        Â  Â  Â  Â  Â  Â  col = int(input("Enter column (0, 1, or 2): "))
        Â  Â  Â  Â  except ValueError:
        Â  Â  Â  Â  Â  Â  continue
        Â  Â  Â  Â  if row not in range(3) or col not in range(3) or board[row]
        [col] != " ":
        Â  Â  Â  Â  Â  Â  continue
        Â  Â  Â  Â  board[row][col] = current_player
        Â  Â  Â  Â  if check_winner(board, current_player):
        Â  Â  Â  Â  Â  Â  print_board(board)
        Â  Â  Â  Â  Â  Â  print(f"Player {current_player} wins!")
        Â  Â  Â  Â  Â  Â  break
        Â  Â  Â  Â  if is_full(board):
        Â  Â  Â  Â  Â  Â  print_board(board)
        Â  Â  Â  Â  Â  Â  print("It's a draw!")
        Â  Â  Â  Â  Â  Â  break
        Â  Â  Â  Â  current_player = "O" if current_player == "X" else "X"
        if __name__ == "__main__":
        Â  Â  play_game()
    
    </textarea>
    
    <button id="btn-program16" onclick="copyProgram('program16', 'btn-program16')">slip16</button>
</div>    

<div class="program-section">
    <h2 class="program-title"></h2>
    
    <textarea id="program17" class="program-code">
Q1 import random
def objective_function(x):
Â  Â  return -(x - 3)**2 + 5
def hill_climbing(start, step_size, max_iterations):
Â  Â  current = start
Â  Â  for _ in range(max_iterations):
Â  Â  Â  Â  neighbors = [current - step_size, current + step_size]
Â  Â  Â  Â  next_move = max(neighbors, key=objective_function)
Â  Â  Â  Â  if objective_function(next_move) <=
objective_function(current):
Â  Â  Â  Â  Â  Â  break
Â  Â  Â  Â  current = next_move
Â  Â  return current, objective_function(current)
if __name__ == "__main__":
Â  Â  start_point = random.uniform(-10, 10)
Â  Â  step_size = 0.1
Â  Â  max_iterations = 100
Â  Â  solution, value = hill_climbing(start_point, step_size, 
max_iterations)
Â  Â  print(f"Best solution found: x = {solution}, f(x) = {value}")

Q2 
    </textarea>
    
    <button id="btn-program17" onclick="copyProgram('program17', 'btn-program17')">slip17</button>
</div>    

<div class="program-section">
    <h2 class="program-title"></h2>
    
    <textarea id="program18" class="program-code">
Q1 import nltk
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
import string
nltk.download('punkt')
nltk.download('stopwords')
Downloaded by Datir Sanskruti (sanskrutidatir528@gmail.com)
lOMoARcPSD|59303612
def remove_stop_words(file_path):
Â  Â  with open(file_path, 'r') as file:
Â  Â  Â  Â  text = file.read()
Â  Â  
Â  Â  words = word_tokenize(text)
Â  Â  stop_words = set(stopwords.words('english'))
Â  Â  filtered_words = [word for word in words if word.lower() not in
stop_words and word.isalpha()]
Â  Â  return ' '.join(filtered_words)
if __name__ == "__main__":
Â  Â  file_path = 'input.txt'
Â  Â  filtered_text = remove_stop_words(file_path)
Â  Â  print("Filtered Text:")
Â  Â  print(filtered_text)
Q.2
import heapq
# Room dimensions (10x10)
room_width = 10
room_height = 10
# Dimensions of rectangular and square objects
rectangular_objects = [(2, 4)] * 5 Â # 5 objects of size 2x4
square_objects = [(3, 3)] * 4 Â  Â  Â  # 4 objects of size 3x3
# Heuristic function: the remaining free area in the room
def heuristic(placed_objects):
Â  Â  used_area = sum([w * h for _, _, w, h in placed_objects]) Â # Unpack
(x, y, width, height)
Â  Â  total_area = room_width * room_height
Â  Â  return total_area - used_area
# State representation: positions and orientations of objects
class State:
Â  Â  def __init__(self, placed_objects, g_cost=0):
Â  Â  Â  Â  self.placed_objects = placed_objects Â # List of (x, y, width, 
height) of placed objects
Â  Â  Â  Â  self.g_cost = g_cost Â  Â  Â  Â  Â  Â  Â  Â  Â # Number of steps taken 
(i.e., objects placed)
Â  Â  Â  Â  self.h_cost = heuristic(placed_objects) Â # Heuristic based on 
remaining space
Â  Â  Â  Â  self.f_cost = self.g_cost + self.h_cost Â # Total cost (g + h)
Â  Â  
Â  Â  def __lt__(self, other):
Â  Â  Â  Â  return self.f_cost < other.f_cost
# Generate valid placements for an object
def generate_actions(placed_objects):
Â  Â  actions = []
Â  Â  all_objects = rectangular_objects + square_objects
Â  Â  for idx, (w, h) in enumerate(all_objects):
Â  Â  Â  Â  if (w, h) not in placed_objects:
Â  Â  Â  Â  Â  Â  for x in range(room_width - w + 1): Â # Try placing 
horizontally
Â  Â  Â  Â  Â  Â  Â  Â  for y in range(room_height - h + 1): Â # Try placing 
vertically
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  # Check for overlap
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  overlap = False
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for px, py, pw, ph in placed_objects:
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if not (x + w <= px or px + pw <= x or y + h <=
py or py + ph <= y):
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  overlap = True
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if not overlap:
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  actions.append((x, y, w, h)) Â # Add valid 
position to place this object
Â  Â  return actions
# A* algorithm to find the optimal arrangement
def a_star():
Â  Â  initial_state = State(placed_objects=[])
Â  Â  open_list = []
Â  Â  closed_list = set()
Â  Â  heapq.heappush(open_list, initial_state)
Â  Â  while open_list:
Â  Â  Â  Â  current_state = heapq.heappop(open_list)
Â  Â  Â  Â  # Check if goal reached (all objects placed)
Â  Â  Â  Â  if len(current_state.placed_objects) ==
len(rectangular_objects) + len(square_objects):
Â  Â  Â  Â  Â  Â  return current_state.placed_objects
Â  Â  Â  Â  if tuple(current_state.placed_objects) in closed_list:
Â  Â  Â  Â  Â  Â  continue
Â  Â  Â  Â  
Â  Â  Â  Â  closed_list.add(tuple(current_state.placed_objects))
Â  Â  Â  Â  # Generate possible actions (placements of objects)
Â  Â  Â  Â  actions = generate_actions(current_state.placed_objects)
Â  Â  Â  Â  for action in actions:
Â  Â  Â  Â  Â  Â  new_placed_objects = current_state.placed_objects +
[(action[0], action[1], action[2], action[3])]
Â  Â  Â  Â  Â  Â  new_state = State(new_placed_objects, 
g_cost=current_state.g_cost + 1)
Â  Â  Â  Â  Â  Â  if tuple(new_placed_objects) not in closed_list:
Â  Â  Â  Â  Â  Â  Â  Â  heapq.heappush(open_list, new_state)
Â  Â  return None
# Start the A* search to arrange the objects
placed_objects = a_star()
if placed_objects:
Â  Â  print("Optimal placement found:")
Â  Â  for placement in placed_objects:
Â  Â  Â  Â  print(f"Object placed at x={placement[0]}, y={placement[1]}
with width={placement[2]} and height={placement[3]}")
else:
Â  Â  print("No valid arrangement found.")

    </textarea>
    
    <button id="btn-program18" onclick="copyProgram('program18', 'btn-program18')">slip18</button>
</div>    

<div class="program-section">
    <h2 class="program-title"></h2>
    
    <textarea id="program19" class="program-code">
    Q1    #hangman
            import random
            words=['ghost','devil','python','iblis','lilith','programming','science']
            word=random.choice(words)
            guessed_letters=[]
            attempts=10

            print("welcoome to hangman !")
            print("__"* len(word))

            while attempts>0:
                 guess=input("\guess a letter").lower()

            if len(guess)!=1 or not guess.isalpha():
               print("please enter a single alpahabet letter")
               continue

            if guess in guessed_letters:
               print("you already guessed that letter ")
               continue
            guessed_letters.append(guess)

            if guess in word:
                print("nice guess")
            else:
                attempts-=1
                print("wrong guess now you have only attempts ",attempts)

            display_word=""
            for letter in word:
                 if letter in guessed_letters:
                     display_word +=letter + ""
                 else:
                      display_word += "__"
            print(display_word.strip())

            if "__" not in display_word:
                print("\n u guessed correct word",word)
                break
    else:
            print("\n sorry no more attempts the word was ",word)

    </textarea>
    
    <button id="btn-program19" onclick="copyProgram('program19', 'btn-program19')">slip19</button>
</div>    

<div class="program-section">
    <h2 class="program-title"></h2>
    
    <textarea id="program20" class="program-code">
Q1 
    class CollegeBot:
Â  Â  def __init__(self, name, college_name, courses, timetable, grades):
Â  Â  Â  Â  self.name = name
Â  Â  Â  Â  self.college_name = college_name
Â  Â  Â  Â  self.courses = courses
Â  Â  Â  Â  self.timetable = timetable
Â  Â  Â  Â  self.grades = grades
Â  Â  def get_personal_info(self):
Â  Â  Â  Â  return f"Name: {self.name}\nCollege: {self.college_name}"
Â  Â  def get_courses(self):
Â  Â  Â  Â  courses_str = "\n".join(self.courses)
Â  Â  Â  Â  return f"Courses enrolled:\n{courses_str}"
Â  Â  def get_timetable(self):
Â  Â  Â  Â  timetable_str = "\n".join([f"{day}: {schedule}" for day, 
schedule in self.timetable.items()])
Â  Â  Â  Â  return f"Your timetable:\n{timetable_str}"
Â  Â  def get_grades(self):
Â  Â  Â  Â  grades_str = "\n".join([f"{course}: {grade}" for course, grade
in self.grades.items()])
Â  Â  Â  Â  return f"Your grades:\n{grades_str}"
Â  Â  def respond(self, query):
Â  Â  Â  Â  query = query.lower()
Â  Â  Â  Â  if "name" in query or "who are you" in query:
Â  Â  Â  Â  Â  Â  return self.get_personal_info()
Â  Â  Â  Â  elif "courses" in query or "enrolled" in query:
Â  Â  Â  Â  Â  Â  return self.get_courses()
Â  Â  Â  Â  elif "timetable" in query or "schedule" in query:
Â  Â  Â  Â  Â  Â  return self.get_timetable()
Â  Â  Â  Â  elif "grades" in query or "marks" in query:
Â  Â  Â  Â  Â  Â  return self.get_grades()
Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  return "Sorry, I didn't understand that. Please ask 
something else."
def main():
Â  Â  name = "John Doe"
Â  Â  college_name = "XYZ University"
Â  Â  courses = ["Mathematics", "Computer Science", "Physics", "History"]
Â  Â  timetable = {
Â  Â  Â  Â  "Monday": "9:00 AM - Math, 11:00 AM - CS",
Â  Â  Â  Â  "Tuesday": "9:00 AM - Physics, 1:00 PM - History",
Â  Â  Â  Â  "Wednesday": "10:00 AM - CS, 2:00 PM - Math",
Â  Â  Â  Â  "Thursday": "9:00 AM - Physics, 1:00 PM - History",
Â  Â  Â  Â  "Friday": "10:00 AM - CS, 12:00 PM - Math"
Â  Â  }
Â  Â  grades = {
Â  Â  Â  Â  "Mathematics": "A",
Â  Â  Â  Â  "Computer Science": "B+",
Â  Â  Â  Â  "Physics": "A-",
Â  Â  Â  Â  "History": "B"
Â  Â  }
Â  Â  bot = CollegeBot(name, college_name, courses, timetable, grades)
Â  Â  
Â  Â  print("Hello! I am your College Bot. You can ask me about your 
college information.")
Â  Â  print("Type 'exit' to end the conversation.\n")
Â  Â  while True:
Â  Â  Â  Â  user_query = input("You: ")
Â  Â  Â  Â  
Â  Â  Â  Â  if user_query.lower() == 'exit':
Â  Â  Â  Â  Â  Â  print("Goodbye! Have a great day!")
Â  Â  Â  Â  Â  Â  break
Â  Â  Â  Â  response = bot.respond(user_query)
Â  Â  Â  Â  print(f"Bot: {response}\n")
if __name__ == "__main__":
Â  Â  main()

Q.2
import math
PLAYER_X = 1
PLAYER_O = -1
EMPTY = 0
def print_board(board):
Â  Â  for row in board:
Â  Â  Â  Â  print(" | ".join(str(cell) if cell != EMPTY else " " for cell
in row))
Â  Â  Â  Â  print("---------")
def check_winner(board, player):
Â  Â  for row in range(3):
Â  Â  Â  Â  if all([board[row][col] == player for col in range(3)]): return
True
Â  Â  for col in range(3):
Â  Â  Â  Â  if all([board[row][col] == player for row in range(3)]): return
True
Â  Â  if all([board[i][i] == player for i in range(3)]): return True
Â  Â  if all([board[i][2-i] == player for i in range(3)]): return True
Â  Â  return False
def is_game_over(board):
Â  Â  return check_winner(board, PLAYER_X) or check_winner(board, 
PLAYER_O) or all(cell != EMPTY for row in board for cell in row)
def evaluate(board):
Â  Â  if check_winner(board, PLAYER_X): return 1
Â  Â  if check_winner(board, PLAYER_O): return -1
Â  Â  return 0
def available_moves(board):
Â  Â  return [(row, col) for row in range(3) for col in range(3) if
board[row][col] == EMPTY]
def minimax(board, is_maximizing_player):
Â  Â  if is_game_over(board): return evaluate(board)
Â  Â  
Â  Â  if is_maximizing_player:
Â  Â  Â  Â  best = -math.inf
Â  Â  Â  Â  for row, col in available_moves(board):
Â  Â  Â  Â  Â  Â  board[row][col] = PLAYER_X
Â  Â  Â  Â  Â  Â  best = max(best, minimax(board, False))
Â  Â  Â  Â  Â  Â  board[row][col] = EMPTY
Â  Â  Â  Â  return best
Â  Â  else:
Â  Â  Â  Â  best = math.inf
Â  Â  Â  Â  for row, col in available_moves(board):
Â  Â  Â  Â  Â  Â  board[row][col] = PLAYER_O
Â  Â  Â  Â  Â  Â  best = min(best, minimax(board, True))
Â  Â  Â  Â  Â  Â  board[row][col] = EMPTY
Â  Â  Â  Â  return best
def find_best_move(board):
Â  Â  best_val = -math.inf
Â  Â  best_move = None
Â  Â  for row, col in available_moves(board):
Â  Â  Â  Â  board[row][col] = PLAYER_X
Â  Â  Â  Â  move_val = minimax(board, False)
Â  Â  Â  Â  board[row][col] = EMPTY
Â  Â  Â  Â  if move_val > best_val:
Â  Â  Â  Â  Â  Â  best_val = move_val
Â  Â  Â  Â  Â  Â  best_move = (row, col)
Â  Â  return best_move
def play_game():
Â  Â  board = [[EMPTY for _ in range(3)] for _ in range(3)]
Â  Â  while not is_game_over(board):
Â  Â  Â  Â  print_board(board)
Â  Â  Â  Â  if sum(row.count(PLAYER_X) for row in board) <=
sum(row.count(PLAYER_O) for row in board):
Â  Â  Â  Â  Â  Â  row, col = find_best_move(board)
Â  Â  Â  Â  Â  Â  board[row][col] = PLAYER_X
Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  row, col = find_best_move(board)
Â  Â  Â  Â  Â  Â  board[row][col] = PLAYER_O
Â  Â  print_board(board)
Â  Â  if check_winner(board, PLAYER_X):
Â  Â  Â  Â  print("Player X wins!")
Â  Â  elif check_winner(board, PLAYER_O):
Â  Â  Â  Â  print("Player O wins!")
Â  Â  else:
Â  Â  Â  Â  print("It's a draw!")
play_game()
    </textarea>
    
    <button id="btn-program20" onclick="copyProgram('program20', 'btn-program20')">slip20</button>
</div>    
  </div>
<script>
    function copyProgram(elementId, buttonId) {
        // à¤ªà¥à¤°à¥‹à¤—à¥à¤°à¤¾à¤® à¤•à¥‹à¤¡ à¤…à¤¸à¤²à¥‡à¤²à¤¾ à¤˜à¤Ÿà¤• (element) à¤®à¤¿à¤³à¤µà¤¾
        const elementToCopy = document.getElementById(elementId);
        const button = document.getElementById(buttonId);
        
        // <textarea> à¤®à¤§à¥‚à¤¨ à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ à¤®à¤¿à¤³à¤µà¤¾
        const textToCopy = elementToCopy.value; 

        // navigator.clipboard API à¤µà¤¾à¤ªà¤°à¥‚à¤¨ à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ à¤•à¥‰à¤ªà¥€ à¤•à¤°à¤¾
        navigator.clipboard.writeText(textToCopy)
            .then(() => {
                // à¤¬à¤Ÿà¤£à¤šà¤¾ à¤®à¤œà¤•à¥‚à¤° à¤¤à¤¾à¤¤à¥à¤ªà¥à¤°à¤¤à¤¾ à¤¬à¤¦à¤²à¤£à¥‡ (Success feedback)
                const originalText = button.innerText;
                button.innerText = 'copied';'calendar'
    
                button.classList.add('copied');
                
                // 1.5 à¤¸à¥‡à¤•à¤‚à¤¦à¤¾à¤‚à¤¨à¤‚à¤¤à¤° à¤¬à¤Ÿà¤£ à¤ªà¥‚à¤°à¥à¤µà¤µà¤¤ à¤•à¤°à¤¾
                setTimeout(() => {
                    button.innerText = originalText;
                    button.classList.remove('copied');
                }, 1500);

            })
            .catch(err => {
                console.error('à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ à¤•à¥‰à¤ªà¥€ à¤•à¤°à¤¤à¤¾à¤¨à¤¾ à¤¤à¥à¤°à¥à¤Ÿà¥€ à¤†à¤²à¥€: ', err);
                alert('à¤•à¥‰à¤ªà¥€ à¤•à¤°à¤£à¥à¤¯à¤¾à¤¤ à¤…à¤ªà¤¯à¤¶ à¤†à¤²à¥‡. à¤¬à¥à¤°à¤¾à¤‰à¤à¤° à¤¸à¥‡à¤Ÿà¤¿à¤‚à¤—à¥à¤œ à¤¤à¤ªà¤¾à¤¸à¤¾ à¤•à¤¿à¤‚à¤µà¤¾ à¤®à¥…à¤¨à¥à¤¯à¥à¤…à¤²à¥€ à¤•à¥‰à¤ªà¥€ à¤•à¤°à¤¾.');
            });
    }
</script>
</body>
</html>
